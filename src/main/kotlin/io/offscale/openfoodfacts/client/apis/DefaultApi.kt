/**
 *
 * Please note:
 * This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * Do not edit this file manually.
 *
 */

@file:Suppress(
    "ArrayInDataClass",
    "EnumEntryName",
    "RemoveRedundantQualifierName",
    "UnusedImport"
)

package io.offscale.openfoodfacts.client.apis

import io.ktor.client.*
import io.ktor.client.engine.cio.*
import io.ktor.http.encodeURLQueryComponent
import java.io.IOException

import io.offscale.openfoodfacts.client.models.GetApiV3TagTagtypeTagOrTagid200Response
import io.offscale.openfoodfacts.client.models.GetApiV3TaxonomySuggestionsTaxonomy200Response
import io.offscale.openfoodfacts.client.models.PatchApiV3ProductBarcode200Response
import io.offscale.openfoodfacts.client.models.PatchApiV3ProductBarcodeRequest
import io.offscale.openfoodfacts.client.models.PostApiV3ProductRevert200Response
import io.offscale.openfoodfacts.client.models.PostApiV3ProductRevertRequest

import io.offscale.openfoodfacts.client.infrastructure.ApiClient
import io.offscale.openfoodfacts.client.infrastructure.ApiResponse
import io.offscale.openfoodfacts.client.infrastructure.ClientException
import io.offscale.openfoodfacts.client.infrastructure.ClientError
import io.offscale.openfoodfacts.client.infrastructure.ServerException
import io.offscale.openfoodfacts.client.infrastructure.ServerError
import io.offscale.openfoodfacts.client.infrastructure.MultiValueMap
import io.offscale.openfoodfacts.client.infrastructure.PartConfig
import io.offscale.openfoodfacts.client.infrastructure.RequestConfig
import io.offscale.openfoodfacts.client.infrastructure.RequestMethod
import io.offscale.openfoodfacts.client.infrastructure.ResponseType
import io.offscale.openfoodfacts.client.infrastructure.Success
import io.offscale.openfoodfacts.client.infrastructure.toMultiValue

class DefaultApi(basePath: kotlin.String = defaultBasePath, client: HttpClient = ApiClient.defaultClient) : ApiClient(basePath, client) {
    companion object {
        @JvmStatic
        val defaultBasePath: String by lazy {
            System.getProperties().getProperty(ApiClient.baseUrlKey, "https://world.openfoodfacts.org")
        }
    }

    /**
     * Get knowledge panels for a tag
     * Return knowledge panels for a tag.  Currently the knowledge panels returned are:  Categories: - Packaging stats for a category
     * @param tagtype Type of the tag
     * @param tagOrTagid Tag name (e.g. yogurts) or tag id (e.g. en:yogurts)
     * @param cc 2 letter code of the country of the user. Used for localizing some fields in returned values (e.g. knowledge panels). If not passed, the country may be inferred by the IP address of the request. (optional)
     * @param lc 2 letter code of the language of the user. Used for localizing some fields in returned values (e.g. knowledge panels). If not passed, the language may be inferred by the Accept-Language header of the request. (optional)
     * @return GetApiV3TagTagtypeTagOrTagid200Response
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun getApiV3TagTagtypeTagOrTagid(tagtype: kotlin.String, tagOrTagid: kotlin.String, cc: kotlin.String? = null, lc: kotlin.String? = null) : GetApiV3TagTagtypeTagOrTagid200Response {
        val localVarResponse = getApiV3TagTagtypeTagOrTagidWithHttpInfo(tagtype = tagtype, tagOrTagid = tagOrTagid, cc = cc, lc = lc)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as GetApiV3TagTagtypeTagOrTagid200Response
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Get knowledge panels for a tag
     * Return knowledge panels for a tag.  Currently the knowledge panels returned are:  Categories: - Packaging stats for a category
     * @param tagtype Type of the tag
     * @param tagOrTagid Tag name (e.g. yogurts) or tag id (e.g. en:yogurts)
     * @param cc 2 letter code of the country of the user. Used for localizing some fields in returned values (e.g. knowledge panels). If not passed, the country may be inferred by the IP address of the request. (optional)
     * @param lc 2 letter code of the language of the user. Used for localizing some fields in returned values (e.g. knowledge panels). If not passed, the language may be inferred by the Accept-Language header of the request. (optional)
     * @return ApiResponse<GetApiV3TagTagtypeTagOrTagid200Response?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun getApiV3TagTagtypeTagOrTagidWithHttpInfo(tagtype: kotlin.String, tagOrTagid: kotlin.String, cc: kotlin.String?, lc: kotlin.String?) : ApiResponse<GetApiV3TagTagtypeTagOrTagid200Response?> {
        val localVariableConfig = getApiV3TagTagtypeTagOrTagidRequestConfig(tagtype = tagtype, tagOrTagid = tagOrTagid, cc = cc, lc = lc)

        return request<Unit, GetApiV3TagTagtypeTagOrTagid200Response>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation getApiV3TagTagtypeTagOrTagid
     *
     * @param tagtype Type of the tag
     * @param tagOrTagid Tag name (e.g. yogurts) or tag id (e.g. en:yogurts)
     * @param cc 2 letter code of the country of the user. Used for localizing some fields in returned values (e.g. knowledge panels). If not passed, the country may be inferred by the IP address of the request. (optional)
     * @param lc 2 letter code of the language of the user. Used for localizing some fields in returned values (e.g. knowledge panels). If not passed, the language may be inferred by the Accept-Language header of the request. (optional)
     * @return RequestConfig
     */
    fun getApiV3TagTagtypeTagOrTagidRequestConfig(tagtype: kotlin.String, tagOrTagid: kotlin.String, cc: kotlin.String?, lc: kotlin.String?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (cc != null) {
                    put("cc", listOf(cc.toString()))
                }
                if (lc != null) {
                    put("lc", listOf(lc.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/api/v3/tag/{tagtype}/{tag_or_tagid}",// TODO: .replace("{"+"tagtype"+"}", tagtype.encodeURLQueryComponent(.toString())).replace("{"+"tag_or_tagid"+"}", encodeURIComponent(tagOrTagid.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * Get taxonomy entries suggestions
     * Open Food Facts uses multilingual [taxonomies](https://wiki.openfoodfacts.org/Global_taxonomies) to normalize entries for categories, labels, ingredients, packaging shapes / materials / recycling instructions and many more fields.  This API returns taxonomy entries suggestions that can be used in product edit forms, search forms etc. (for instance in autocomplete dropdowns using libraries like Tagify or select2 on the Web).  Suggestions filtering:  The string parameter allows to get only suggestions that contain a specific string (useful for autocomplete suggestions).  Suggestions ordering:  - For packaging shapes and materials, suggestions are ordered first by the number of packaging components they appear in (restricted by country, categories and shape (for materials) if they are passed as parameters). - for all other taxonomies, results are ordered alphabetically  If a string is passed, an additional sort is done to put first suggestions that start with the string, followed by suggestions with a word that start with the string, and then suggestions that contain the string anywhere.
     * @param tagtype  (optional)
     * @param cc 2 letter code of the country of the user. Used for localizing some fields in returned values (e.g. knowledge panels). If not passed, the country may be inferred by the IP address of the request. (optional)
     * @param lc 2 letter code of the language of the user. Used for localizing some fields in returned values (e.g. knowledge panels). If not passed, the language may be inferred by the Accept-Language header of the request. (optional)
     * @param string Optional string used to filter suggestions (useful for autocomplete).  If passed, suggestions starting with the string will be returned first, followed by suggestions matching the string at the beginning of a word, and suggestions matching the string inside a word. (optional)
     * @param categories Comma separated list of categories tags (e.g. \&quot;en:fats,en:unsalted-butters\&quot; or categories names in the language indicated by the \&quot;lc\&quot; field (e.g. \&quot;graisses, beurres salés\&quot; in French) (optional)
     * @param shape Shape of packaging component (tag identified in the packaging_shapes taxonomy, or plain text tag name in the language indicated by the \&quot;lc\&quot; field) (optional)
     * @param limit Maximum number of suggestions. Default is 25, max is 400. (optional)
     * @param getSynonyms Whether or not to include \&quot;matched_synonyms\&quot; in the response. Set to 1 to include. (optional)
     * @param term Alias for the \&quot;string\&quot; parameter provided for backward compatibility. \&quot;string\&quot; takes precedence. (optional)
     * @return GetApiV3TaxonomySuggestionsTaxonomy200Response
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun getApiV3TaxonomySuggestionsTaxonomy(tagtype: kotlin.String? = null, cc: kotlin.String? = null, lc: kotlin.String? = null, string: kotlin.String? = null, categories: kotlin.String? = null, shape: kotlin.String? = null, limit: kotlin.String? = null, getSynonyms: kotlin.String? = null, term: kotlin.String? = null) : GetApiV3TaxonomySuggestionsTaxonomy200Response {
        val localVarResponse = getApiV3TaxonomySuggestionsTaxonomyWithHttpInfo(tagtype = tagtype, cc = cc, lc = lc, string = string, categories = categories, shape = shape, limit = limit, getSynonyms = getSynonyms, term = term)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as GetApiV3TaxonomySuggestionsTaxonomy200Response
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Get taxonomy entries suggestions
     * Open Food Facts uses multilingual [taxonomies](https://wiki.openfoodfacts.org/Global_taxonomies) to normalize entries for categories, labels, ingredients, packaging shapes / materials / recycling instructions and many more fields.  This API returns taxonomy entries suggestions that can be used in product edit forms, search forms etc. (for instance in autocomplete dropdowns using libraries like Tagify or select2 on the Web).  Suggestions filtering:  The string parameter allows to get only suggestions that contain a specific string (useful for autocomplete suggestions).  Suggestions ordering:  - For packaging shapes and materials, suggestions are ordered first by the number of packaging components they appear in (restricted by country, categories and shape (for materials) if they are passed as parameters). - for all other taxonomies, results are ordered alphabetically  If a string is passed, an additional sort is done to put first suggestions that start with the string, followed by suggestions with a word that start with the string, and then suggestions that contain the string anywhere.
     * @param tagtype  (optional)
     * @param cc 2 letter code of the country of the user. Used for localizing some fields in returned values (e.g. knowledge panels). If not passed, the country may be inferred by the IP address of the request. (optional)
     * @param lc 2 letter code of the language of the user. Used for localizing some fields in returned values (e.g. knowledge panels). If not passed, the language may be inferred by the Accept-Language header of the request. (optional)
     * @param string Optional string used to filter suggestions (useful for autocomplete).  If passed, suggestions starting with the string will be returned first, followed by suggestions matching the string at the beginning of a word, and suggestions matching the string inside a word. (optional)
     * @param categories Comma separated list of categories tags (e.g. \&quot;en:fats,en:unsalted-butters\&quot; or categories names in the language indicated by the \&quot;lc\&quot; field (e.g. \&quot;graisses, beurres salés\&quot; in French) (optional)
     * @param shape Shape of packaging component (tag identified in the packaging_shapes taxonomy, or plain text tag name in the language indicated by the \&quot;lc\&quot; field) (optional)
     * @param limit Maximum number of suggestions. Default is 25, max is 400. (optional)
     * @param getSynonyms Whether or not to include \&quot;matched_synonyms\&quot; in the response. Set to 1 to include. (optional)
     * @param term Alias for the \&quot;string\&quot; parameter provided for backward compatibility. \&quot;string\&quot; takes precedence. (optional)
     * @return ApiResponse<GetApiV3TaxonomySuggestionsTaxonomy200Response?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun getApiV3TaxonomySuggestionsTaxonomyWithHttpInfo(tagtype: kotlin.String?, cc: kotlin.String?, lc: kotlin.String?, string: kotlin.String?, categories: kotlin.String?, shape: kotlin.String?, limit: kotlin.String?, getSynonyms: kotlin.String?, term: kotlin.String?) : ApiResponse<GetApiV3TaxonomySuggestionsTaxonomy200Response?> {
        val localVariableConfig = getApiV3TaxonomySuggestionsTaxonomyRequestConfig(tagtype = tagtype, cc = cc, lc = lc, string = string, categories = categories, shape = shape, limit = limit, getSynonyms = getSynonyms, term = term)

        return request<Unit, GetApiV3TaxonomySuggestionsTaxonomy200Response>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation getApiV3TaxonomySuggestionsTaxonomy
     *
     * @param tagtype  (optional)
     * @param cc 2 letter code of the country of the user. Used for localizing some fields in returned values (e.g. knowledge panels). If not passed, the country may be inferred by the IP address of the request. (optional)
     * @param lc 2 letter code of the language of the user. Used for localizing some fields in returned values (e.g. knowledge panels). If not passed, the language may be inferred by the Accept-Language header of the request. (optional)
     * @param string Optional string used to filter suggestions (useful for autocomplete).  If passed, suggestions starting with the string will be returned first, followed by suggestions matching the string at the beginning of a word, and suggestions matching the string inside a word. (optional)
     * @param categories Comma separated list of categories tags (e.g. \&quot;en:fats,en:unsalted-butters\&quot; or categories names in the language indicated by the \&quot;lc\&quot; field (e.g. \&quot;graisses, beurres salés\&quot; in French) (optional)
     * @param shape Shape of packaging component (tag identified in the packaging_shapes taxonomy, or plain text tag name in the language indicated by the \&quot;lc\&quot; field) (optional)
     * @param limit Maximum number of suggestions. Default is 25, max is 400. (optional)
     * @param getSynonyms Whether or not to include \&quot;matched_synonyms\&quot; in the response. Set to 1 to include. (optional)
     * @param term Alias for the \&quot;string\&quot; parameter provided for backward compatibility. \&quot;string\&quot; takes precedence. (optional)
     * @return RequestConfig
     */
    fun getApiV3TaxonomySuggestionsTaxonomyRequestConfig(tagtype: kotlin.String?, cc: kotlin.String?, lc: kotlin.String?, string: kotlin.String?, categories: kotlin.String?, shape: kotlin.String?, limit: kotlin.String?, getSynonyms: kotlin.String?, term: kotlin.String?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (tagtype != null) {
                    put("tagtype", listOf(tagtype.toString()))
                }
                if (cc != null) {
                    put("cc", listOf(cc.toString()))
                }
                if (lc != null) {
                    put("lc", listOf(lc.toString()))
                }
                if (string != null) {
                    put("string", listOf(string.toString()))
                }
                if (categories != null) {
                    put("categories", listOf(categories.toString()))
                }
                if (shape != null) {
                    put("shape", listOf(shape.toString()))
                }
                if (limit != null) {
                    put("limit", listOf(limit.toString()))
                }
                if (getSynonyms != null) {
                    put("get_synonyms", listOf(getSynonyms.toString()))
                }
                if (term != null) {
                    put("term", listOf(term.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/api/v3/taxonomy_suggestions",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * WRITE Product - Create or update product, or analyze test product (API V3 - Implementation in progress)
     * This API allows to create or update a product (if the product already exists, its data is updated, otherwise it is created), or to analyze a test product (in which case no product is created or updated). To analyze a product, the \&quot;barcode\&quot; path component needs to contain the value \&quot;test\&quot; instead of a barcode.  New API to send structured product data in a JSON format instead of in a flattened list of key / value pairs field as-in the current product add / edit API that relies on a multipart/form-data format.  Important: this new Product WRITE API is under development. The initial deployment will support only packaging fields.  This new API will be used in particular to send structured packaging data: https://openfoodfacts.github.io/openfoodfacts-server/dev/explain-packaging-data/  The new API can then be gradually extended to support other product fields.
     * @param barcode Barcode of the product to create or update, or \&quot;test\&quot; to analyze the product data sent without creating or updating a product
     * @param patchApiV3ProductBarcodeRequest Structured data for the product is passed in the product field.  For complex structures such as the packagings object, it is possible to replace pre-existing data, or completing it:  - an object sent in the packagings field will replace any pre-existing data. - an object sent in the field suffixed with _add (e.g. packagings_add) will be merged with any pre-existing data.  (optional)
     * @return PatchApiV3ProductBarcode200Response
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun patchApiV3ProductBarcode(barcode: kotlin.String, patchApiV3ProductBarcodeRequest: PatchApiV3ProductBarcodeRequest? = null) : PatchApiV3ProductBarcode200Response {
        val localVarResponse = patchApiV3ProductBarcodeWithHttpInfo(barcode = barcode, patchApiV3ProductBarcodeRequest = patchApiV3ProductBarcodeRequest)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as PatchApiV3ProductBarcode200Response
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * WRITE Product - Create or update product, or analyze test product (API V3 - Implementation in progress)
     * This API allows to create or update a product (if the product already exists, its data is updated, otherwise it is created), or to analyze a test product (in which case no product is created or updated). To analyze a product, the \&quot;barcode\&quot; path component needs to contain the value \&quot;test\&quot; instead of a barcode.  New API to send structured product data in a JSON format instead of in a flattened list of key / value pairs field as-in the current product add / edit API that relies on a multipart/form-data format.  Important: this new Product WRITE API is under development. The initial deployment will support only packaging fields.  This new API will be used in particular to send structured packaging data: https://openfoodfacts.github.io/openfoodfacts-server/dev/explain-packaging-data/  The new API can then be gradually extended to support other product fields.
     * @param barcode Barcode of the product to create or update, or \&quot;test\&quot; to analyze the product data sent without creating or updating a product
     * @param patchApiV3ProductBarcodeRequest Structured data for the product is passed in the product field.  For complex structures such as the packagings object, it is possible to replace pre-existing data, or completing it:  - an object sent in the packagings field will replace any pre-existing data. - an object sent in the field suffixed with _add (e.g. packagings_add) will be merged with any pre-existing data.  (optional)
     * @return ApiResponse<PatchApiV3ProductBarcode200Response?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun patchApiV3ProductBarcodeWithHttpInfo(barcode: kotlin.String, patchApiV3ProductBarcodeRequest: PatchApiV3ProductBarcodeRequest?) : ApiResponse<PatchApiV3ProductBarcode200Response?> {
        val localVariableConfig = patchApiV3ProductBarcodeRequestConfig(barcode = barcode, patchApiV3ProductBarcodeRequest = patchApiV3ProductBarcodeRequest)

        return request<PatchApiV3ProductBarcodeRequest, PatchApiV3ProductBarcode200Response>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation patchApiV3ProductBarcode
     *
     * @param barcode Barcode of the product to create or update, or \&quot;test\&quot; to analyze the product data sent without creating or updating a product
     * @param patchApiV3ProductBarcodeRequest Structured data for the product is passed in the product field.  For complex structures such as the packagings object, it is possible to replace pre-existing data, or completing it:  - an object sent in the packagings field will replace any pre-existing data. - an object sent in the field suffixed with _add (e.g. packagings_add) will be merged with any pre-existing data.  (optional)
     * @return RequestConfig
     */
    fun patchApiV3ProductBarcodeRequestConfig(barcode: kotlin.String, patchApiV3ProductBarcodeRequest: PatchApiV3ProductBarcodeRequest?) : RequestConfig<PatchApiV3ProductBarcodeRequest> {
        val localVariableBody = patchApiV3ProductBarcodeRequest
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.PATCH,
            path = "/api/v3/product/{barcode}", // TODO: .replace("{"+"barcode"+"}",  encodeURIComponent(barcode.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * Revert a product to a previous revision
     * For moderators only, revert a product to a previous revision.
     * @param postApiV3ProductRevertRequest The code and rev fields are mandatory.  (optional)
     * @return PostApiV3ProductRevert200Response
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun postApiV3ProductRevert(postApiV3ProductRevertRequest: PostApiV3ProductRevertRequest? = null) : PostApiV3ProductRevert200Response {
        val localVarResponse = postApiV3ProductRevertWithHttpInfo(postApiV3ProductRevertRequest = postApiV3ProductRevertRequest)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as PostApiV3ProductRevert200Response
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Revert a product to a previous revision
     * For moderators only, revert a product to a previous revision.
     * @param postApiV3ProductRevertRequest The code and rev fields are mandatory.  (optional)
     * @return ApiResponse<PostApiV3ProductRevert200Response?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun postApiV3ProductRevertWithHttpInfo(postApiV3ProductRevertRequest: PostApiV3ProductRevertRequest?) : ApiResponse<PostApiV3ProductRevert200Response?> {
        val localVariableConfig = postApiV3ProductRevertRequestConfig(postApiV3ProductRevertRequest = postApiV3ProductRevertRequest)

        return request<PostApiV3ProductRevertRequest, PostApiV3ProductRevert200Response>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation postApiV3ProductRevert
     *
     * @param postApiV3ProductRevertRequest The code and rev fields are mandatory.  (optional)
     * @return RequestConfig
     */
    fun postApiV3ProductRevertRequestConfig(postApiV3ProductRevertRequest: PostApiV3ProductRevertRequest?) : RequestConfig<PostApiV3ProductRevertRequest> {
        val localVariableBody = postApiV3ProductRevertRequest
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/api/v3/product_revert",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }
}
